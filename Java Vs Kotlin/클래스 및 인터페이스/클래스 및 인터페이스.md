# 클래스 및 인터페이스
## 클래스 및 인터페이스
* Java와 유사하지만 새로운 개념이 추가되거나 약간 다른 방식이 있기도 합니다.

## 클래스와 인터페이스의 선언 및 인스턴스 생성
* 선언 법은 Java와 거의 동일합니다.
```
package foo.bar;

class Baz {

}
```
* Kotlin에서 접근 제한자를 지정하지 않은 경우엔 public으로 간주합니다.
```
// 클래스 본체 없이 클래스를 선언할 수 있습니다.
class Foo
```
* 인터페이스도 동일합니다.
```
interface Foo{

}
// 인터페이스 본체 없이 Interface를 선언하는 것도 가능합니다.
interface Foo
```
* Kotlin은 클래스의 인스턴스를 생성하지 위해 new 키워드를 사용하지 않습니다.
```
// new 키워드 생략
val foo: Foo = Foo()

// 인자 하나를 받는 생성자로 인스턴스 생성
val bar: Bar = Bar(1)
```
* 추상 클래스(abstract class)는 Java와 동일한 방법으로 선언하지만, 추상 클래스의 인스턴스를 생성하는 형태는 매우 다릅니다.
```
 // 추상 클래스 선언
abstract class Foo {
    abstract fun bar()
}

// 추상 클래스의 인스턴스 생성
// object: [생성자] 형태로 선언
val foo = object : Foo(){

    override fun bar(){
        // 함수 구현
    }
}
```
* Interface를 선언하고 인스턴스를 생성하는 방법은 Java와 유사합니다.
```
// 인터페이스 선언
interface Bar {
    fun baz()
}

// 인터페이스의 인스턴스 생성
// object: [인터페이스 이름] 형태로 선언
val bar = object : Bar {
    override fun baz() {
        // 함수 구현
    }
}
```
* 유의: 추상클래스에서는 인스턴스 생성 시 생성자를 사용하지만, 생성자가 없는 인스턴스는 인스턴스 이름만 사용합니다.

## 프로퍼티
* Java에서는 자료를 저장하기 위해 Getter/Setter를 이용해야 했습니다. 하지만 이는 불필요한 코드의 양을 늘렸습니다.
* Kotlin에서는 이런 불편함을 해결하기 위해 프로퍼티(property)를 사용합니다.
* 프로퍼티는 자료를 저장할 수 있는 필드와 이에 상응하는 Getter/Setter 메서드를 함께 제공하며 필드와 유사한 형태로 선언합니다.
```
class Person {
    var name : String? = null
    var address : String? = null
}
```
* 프로퍼티의 타입으로 String?을 사용함은 널(null) 값이 들어갈 수 있음을 의미합니다.

* Kotlin의 프로퍼티도 값(val) 혹은 변수(var) 중 하나로 선언합니다.
* Getter/Setter 메서드가 모두 존재하는 한 값은 언제든 바뀔 수 있기 때문에 var로 선언하고 읽기만 할 수 있는 자료는 val로 선언합니다.
```
class Person{
    val name : String? = null // 값을 읽을 수만 있는 val
    var address :String? = null // 값을 읽고 쓰는 게 모두 가능한 var
}
```
* null을 명시적으로 할당한 이유는 Kotlin에서는 클래스의 멤버로 사용하는 프로퍼티는 초깃값을 명시적으로 지정해야 하기 때문입니다.
* 단, 생성자에서 프로퍼티의 값을 할당한다면 선언 시 할당하지 않아도 됩니다.
* 프로퍼티 선언 시점이나 생성자 호출 시점에 값을 할당할 수 없는 경우에는 lateinit 키워드를 사용하여 이 프로퍼티의 값이 나중에 할당 될 것임을 명시합니다.
lateinit 키워트는 var 프로퍼티에만 사용 가능하며, 선언 시점에 값 할당을 요구하는 val 프로퍼티에는 사용할 수 없습니다.
```
class Person {
    val name : String? = null // val 프로퍼티는 항상 선언과 함꼐 값을 할당해야 합니다.

    lateinit var address : String? // 선언 시점에 값을 할당하지 않아도 컴파일 에러가 발생X
}
```
* 만약 lateinit 키워드를 사용한 프로퍼티를 초기화 없이 사용하여 한다면 Uninitialized PropertyAccessException 예외가 발생합니다.
* 이 키워드를 사용할 경우 프로퍼티의 초기화 여부를 확인하는 것이 좋습니다.
* 프로퍼티에 초깃값을 할당하는 시점에서 해당 프로퍼티의 타입을 추론할 수 있다면, 타입 선언을 생략할 수 있습니다.
```
class Person {
    var name = "No Name" // var name : String = "No Name"과 동일합니다.

    var address : String? = null // null만으로는 타입을 추론할 수 없기에 타입 선언이 필요합니다.
}
```

## 접근 제한자
* Kotlin에서도 Java에서 처럼 접근 제한자를 클래스와 함수, 프로퍼티의 가시성을 제어하기 위해 사용합니다.
```
class Foo{
    // 접근 제한자가 없으면
    // public으로 간주합니다.
    val a = 1

    protected val b = 2
    private val c = 3

    // internal을 대신 사용합니다.
    internal val d = 4
}
```
* public 제한자는 제한자가 없을 시 자동으로 취급되므로 생략하는 것이 좋습니다.
* 이런 접근 제한자는 패키지 단위라서 견고하지 못하다는 단점이 있었으나 Kotlin에서는 internal 접근 제한자를 제공하여 해결하였습니다.
* internal 접근 제한자는 동일한 모듈 내에 있는 클래스들로의 접근을 제한합니다.
따라서 외부 모듈에서는 이 접근 제한자로 선언된 요소에 접근할 수 없습니다.
* '모듈'의 범위
1. InteliJ IDEA 모듈
2. Maven/Gradle 프로젝트
3. 하나의 Ant 태스트 내에서 함께 컴파일되는 파일들

## 생성자
* Kotlin에서는 Java와 달리 생성자를 좀 더 명확한 방법으로 정의합니다.
```
init {
    // 생성자에서 수행할 작업들
}
```
* Kotlin은 init 블록을 사용하여 기본 생성자를 대체합니다.
* 생성자에서 인자를 받아야 할 때(주 생성자 primary constructor)에는 여기서 받은 인자는 init블록에서 사용이 가능합니다.
```
class Foo(a: Int) {
    init {
        Log.d("Foo", "Number: $a")
    }
}
```
* 생성자의 인자를 통해 바로 클래스 내부의 프로퍼티에 값을 할당할 수 있습니다. 이 경우 추가적으로 프로퍼티 선언을 하지 않아도 됩니다.
* Kotlin은 생성자의 인자에서 프로퍼티 선언도 이루어지고, 값 할당도 생성자 호출과 동시에 수행됩니다.
```
class Foo(val a: Int, var b: Char)
```
* 또 다른 생성자가 필요할 경우에는 constructor 키워드를 이용하여 추가 생성자를 선언할 수 있습니다.
```
class Foo(val a: Int, var b: Char){

    // a의 값만 인자로 받는 추가 생성자
    // 기본 생성자를 반드시 호출해야 합니다.
    constructor(a: Int) : this(a, 0)

    // 두 인자의 값을 모두 0으로 지정하는 생성자
    constructor(): this(0, 0)
}
```
* 추가 생성자를 정의하는 경우 주 생성자를 반드시 호출해야합니다.
* 추가 생성자에서는 프로퍼티와 인자를 함께 생성할 수 없어서 주 생성자에서 프로퍼티 선언을 해주어야 합니다.
* 생성자의 가시성을 변경하려면 constructor 키워드 앞에 접근 제한자를 추가하고 
주 생성자에서는 constructor를 추가하고 접근 제한자도 추가하면 됩니다.
```
// 주 생서자의 가시성을 internal로 지정, constructor 키워드 표기 필요
class Fo internal constructor(val a: Int, var b: Car) {
    // 추가 생성자의 가시성 지정
    private constructor(a: Int) : this(a, 0)

    // 접근 제한자를 지정하지 않았으므로 public
    constructor(): this(0, 0)
}
```
## 함수
* Kotlin에서는 클래스 내 메서드를 함수(funtion)로 표현합니다.
```
class Foo {
    // 아무 값도 반환하지 않는 함수
    fun foo(): Unit {

    }

    // 정수 값을 반환하는 함수
    private fun bar() : Int {
        return 0
    }
}
```
* 특별한 값을 반환하지 않는 경우 '함수 자체'를 의미하는 Unit 타입을 반환합니다. Unit 타입은 생략 가능합니다.
```
// 특별한 값을 반환하지 않는 함수는 반환 타입을 생략할 수 있습니다.
fun foo(){

}
```
## 상속 및 인터페이스 구현
* Kotlin은 클래스의 상속과 인터페이스의 구현은 : 뒤에 이들을 표기하는 것으로 대체합니다.
```
class MainActivity:
    AppCompatActivity(),
    View.OnClickListener {

    }
```
* 클래스를 상속하는 경우 반드시 부모 클래스의 생성자를 호출해야합니다.
* 부모 클래스의 생성자가 여러 형태일 경우, 클래스 선언부에서 부모 클래스의 생성자를 호출하는 대신 별도의 생성자 선언에서 부모 클래스의 생성자를 호출하도록 구현할 수 있습니다.
* 부모 클래스의 생성자는 자바와 동일하게 super 키워드를 사용하여 호출합니다.
```
class MyView : View {
    constructor(context: Context) : super(context) {
        // 뷰 초기화
    }
    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {
        // 뷰 초기화
    }
}
```
* 생성자가 여럿인 경우 this 키워드를 사용하여 자기 자시느이 생성자를 호출할 수 있습니다. 
```
class MyView : View {
    constructor(context: Context) : this(context, null)

    constructor(context: Context, attrs: AttributeSet?) : super(context, attrs) {
        // 뷰 초기화
    }
}
```
* Kotlin에서는 상속받거나 구현한 함수의 앞에 무조건 override 키워드를 붙이도록 강제합니다. (@Override와 동일)
```
class MyActicity: AppCompatActivity(), View.OnClickListener {
    // AppCompatActivity의 onCreate() 메서드 상속
    override fun onCreate(savedInstanceState: Bundle?) { 
        super,onCreate(savedInstanceState)
    }

    // View.On
}
```