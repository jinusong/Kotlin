# Immutability

## 불변성이란?
* 본질적으로 함수형 프로그래밍은 스레드 안전입니다.
* 불변성은 스레드를 안전하게 만드는 데 큰 역할을 합니다.
* 사전적인 정의로 가면 불변성은 무언가가 변할 수 없다는 것을 의미합니다.
* 실제로 불변성은 변경 금지에 대한 것이 아니라 변경 처리에 대한 것입니다.
* 속성의 값을 직접 변경하는 대신 새 속성을 만들고 적용된 변경 사항으로 값을 복사합니다.

* 대부분의 기본 유형은 동일한 방식으로 작동하고 그것이 불변성이라고 부르는 것입니다.

## 불변성의 장점

### 스레드 안정성
* 여러 스레드에서 클래스에 접근할 때 오브젝트 잠금 및 해제와 동기화 같은 것으로 보장해야 하지만, 여러 스레드에서 불변 데이터에 접근할 때는 이런 것이 필요하지 않습니다.

### 낮은 커플링
* 스레드 간의 코드 의존성을 커플링이라고 하는데 복잡성을 피하고 코드 베이스를 읽기 쉽고 유지 보수하기 쉽도록 커플링을 최대한 낮게 유지해야 합니다.
* 불변성을 도입한 곳에서는 커플링이 감소합니다. 한 스레드의 작업과 변경이 다른 스레드에 영향을 주지 않았기 때문입니다.

### 참조 투명성
* 참조 투명성의 개념은 컨텍스트나 다른 분산과 관계없이 표현식이 언제나 같은 값을 평가한다는 것입니다.
* 순수 함수의 도음이 있으면 불변은 참조 투명성을 확립할 수 있습니다. 참조 투명성은 가변 상태의 데이터를 강력하게 거부합니다.

### 실패 원자성
* 전통적 프로그래밍에서 한 스레드의 실패는 다른 스레드에 쉽게 영향을 미칠 수 있습니다.
* 불변성은 낮은 커플링을 강요하므로 애플리케이션의 내부 상태는 어떤 모듈/스레드에서 예외가 발생하더라도 일관성이 있습니다.
* 불변 오브젝트는 절대로 상태를 변경하지 않습니다.
* 따라서 한파트/모듈/스레드에서 에러가 발생하더라도 거기서 바로 멈추며, 애플리케이션의 다른 부분으로 확산될 가능성을 갖지 않습니다.

### 캐싱
* 불변 오브젝트는 변경되지 않으므로 성능 향상을 위해 쉽게 캐싱할 수 있습니다.
* 동일한 함수/변수를 여러번 호출하는 것을 쉽게 피할 수 있으며, 대신에 로컬로 캐싱하고 충분한 처리 시간을 절약할 수 있습니다.

### 컴파일러 최적화
* 불변성과 참조 투명성은 컴파일러가 광범위한 최적화를 할 수 있게 도우므로 코드에서 수동 최적화의 필요성을 대체하고 프로그래머를 이 교환으로부터 자유롭게 합니다.

### 순수 함수
* 순수 함수는 불변성을 사용해 얻을 수 있는 가장 큰 것입니다.
* 불변성 없는 순수함수를 구현할 수 없으며, 순수함수 없이 불변성을 완성할 수 없습니다.

## 코틀린에서 불변성의 구현방법
* 코틀린은 불변 변수를 갖지만 상태의 진정한 깊은 불변성을 보장하는 언어 메커니즘은 없습니다.
* val 변수가 가변 오브젝트를 참조한다면 여전히 내용을 수정할 수 있습니다.
* 우선 var, val, const val의 차이점을 살펴봅니다.

## val과 var 
* var는 다른 명령형 언어에 있는 것과 같이 그저 단순한 변수입니다.
* val는 불변성에 좀 더 가깝습니다.
* 커스텀 게터 없이 val 변수를 사용하면 참조 불변성을 얻을 수 있습니다.
* 그래서 val로는 불변성을 보장할 수 없습니다.

## val와 const val: 정말 변하지 않을까?
* val와 const val의 차이점
    * val 속성은 읽기 전용 변수이지만 const val은 컴파일 타임상수입니다.
    * 함수의 출력을 const val에 대입할 수 없습니다.
    * val 속성은 커스텀 게터를 가질 수 있지만, const val는 불가능합니다.
    * const val는 클래스/오브젝트의 최상위 멤버여야만 합니다.
    * const val 속성을 위한 델리게이트를 작성할 수 없습니다.
    * 모든 타입에 대한 val 속성을 가질 수 있지만 const val는 기본 데이터 타입과 문자열만 될 수 있습니다.
    * const val 속성의 null 가능한 데이터 타입을 가질 수 없습니다. 그 결과 const val 속성의 null 값을 가질 수도 없습니다.

* 결과적으로 const val 속성은 값의 불변성을 보장하지만 유연성은 떨어집니다.
* 그리고 const val로 오직 기본 데이터 타입만 사용해야 하므로 항상 목적을 달성할 수는 없습니다.

## 불변성의 종류
### 참조 불변
* 참조 불변은 일단 참조가 할당되면 다른 것에 할당될 수 없게 합니다.
### 불변값
* 불변 값은 값을 변경하지 않게 합니다.
* 따라서 유저 관리가 정말로 복잡합니다.
* 코틀린에서 const val 속성은 값의 불변성을 강요하지만 융통성이 부족해 기본 타입만 사용해야 합니다.

## 불변성의 단점
* 불변성에 대해 들을 수 있는 것은 그 것을 수정할 때마다 새로운 오부젝트를 생성해야 한다는 점입니다.
* 일부 시나리오에서는, 특히 많은 오브젝트 세트로 작업하는 곳에는 맞는 말입니다.
* 그러나 작은 데이터셋이나 오브젝트로 작업할 때는 영향을 주지 않습니다.